{"ast":null,"code":"import { Circle, DivType, ExternalInteractorBase, Rectangle, colorMix, divMode, divModeExecute, getDistance, getRangeMax, isDivModeEnabled, isInArray, itemFromSingleOrMultiple, millisecondsToSeconds, mouseLeaveEvent, mouseMoveEvent, rangeColorToHsl, rgbToHsl } from \"@tsparticles/engine\";\nimport { Bubble } from \"./Options/Classes/Bubble.js\";\nimport { ProcessBubbleType } from \"./Enums.js\";\nimport { calculateBubbleValue } from \"./Utils.js\";\nconst bubbleMode = \"bubble\",\n  minDistance = 0,\n  defaultClickTime = 0,\n  double = 2,\n  defaultOpacity = 1,\n  ratioOffset = 1,\n  defaultBubbleValue = 0,\n  minRatio = 0,\n  half = 0.5,\n  defaultRatio = 1;\nexport class Bubbler extends ExternalInteractorBase {\n  constructor(container, engine) {\n    super(container);\n    this._clickBubble = () => {\n      const container = this.container,\n        options = container.actualOptions,\n        mouseClickPos = container.interactivity.mouse.clickPosition,\n        bubbleOptions = options.interactivity.modes.bubble;\n      if (!bubbleOptions || !mouseClickPos) {\n        return;\n      }\n      if (!container.bubble) {\n        container.bubble = {};\n      }\n      const distance = container.retina.bubbleModeDistance;\n      if (!distance || distance < minDistance) {\n        return;\n      }\n      const query = container.particles.quadTree.queryCircle(mouseClickPos, distance, p => this.isEnabled(p)),\n        {\n          bubble\n        } = container;\n      for (const particle of query) {\n        var _container$interactiv, _particle$opacity$val, _particle$opacity;\n        if (!bubble.clicking) {\n          continue;\n        }\n        particle.bubble.inRange = !bubble.durationEnd;\n        const pos = particle.getPosition(),\n          distMouse = getDistance(pos, mouseClickPos),\n          timeSpent = (new Date().getTime() - ((_container$interactiv = container.interactivity.mouse.clickTime) !== null && _container$interactiv !== void 0 ? _container$interactiv : defaultClickTime)) / millisecondsToSeconds;\n        if (timeSpent > bubbleOptions.duration) {\n          bubble.durationEnd = true;\n        }\n        if (timeSpent > bubbleOptions.duration * double) {\n          bubble.clicking = false;\n          bubble.durationEnd = false;\n        }\n        const sizeData = {\n          bubbleObj: {\n            optValue: container.retina.bubbleModeSize,\n            value: particle.bubble.radius\n          },\n          particlesObj: {\n            optValue: getRangeMax(particle.options.size.value) * container.retina.pixelRatio,\n            value: particle.size.value\n          },\n          type: ProcessBubbleType.size\n        };\n        this._process(particle, distMouse, timeSpent, sizeData);\n        const opacityData = {\n          bubbleObj: {\n            optValue: bubbleOptions.opacity,\n            value: particle.bubble.opacity\n          },\n          particlesObj: {\n            optValue: getRangeMax(particle.options.opacity.value),\n            value: (_particle$opacity$val = (_particle$opacity = particle.opacity) === null || _particle$opacity === void 0 ? void 0 : _particle$opacity.value) !== null && _particle$opacity$val !== void 0 ? _particle$opacity$val : defaultOpacity\n          },\n          type: ProcessBubbleType.opacity\n        };\n        this._process(particle, distMouse, timeSpent, opacityData);\n        if (!bubble.durationEnd && distMouse <= distance) {\n          this._hoverBubbleColor(particle, distMouse);\n        } else {\n          delete particle.bubble.color;\n        }\n      }\n    };\n    this._hoverBubble = () => {\n      const container = this.container,\n        mousePos = container.interactivity.mouse.position,\n        distance = container.retina.bubbleModeDistance;\n      if (!distance || distance < minDistance || !mousePos) {\n        return;\n      }\n      const query = container.particles.quadTree.queryCircle(mousePos, distance, p => this.isEnabled(p));\n      for (const particle of query) {\n        particle.bubble.inRange = true;\n        const pos = particle.getPosition(),\n          pointDistance = getDistance(pos, mousePos),\n          ratio = ratioOffset - pointDistance / distance;\n        if (pointDistance <= distance) {\n          if (ratio >= minRatio && container.interactivity.status === mouseMoveEvent) {\n            this._hoverBubbleSize(particle, ratio);\n            this._hoverBubbleOpacity(particle, ratio);\n            this._hoverBubbleColor(particle, ratio);\n          }\n        } else {\n          this.reset(particle);\n        }\n        if (container.interactivity.status === mouseLeaveEvent) {\n          this.reset(particle);\n        }\n      }\n    };\n    this._hoverBubbleColor = (particle, ratio, divBubble) => {\n      const options = this.container.actualOptions,\n        bubbleOptions = divBubble !== null && divBubble !== void 0 ? divBubble : options.interactivity.modes.bubble;\n      if (!bubbleOptions) {\n        return;\n      }\n      if (!particle.bubble.finalColor) {\n        const modeColor = bubbleOptions.color;\n        if (!modeColor) {\n          return;\n        }\n        const bubbleColor = itemFromSingleOrMultiple(modeColor);\n        particle.bubble.finalColor = rangeColorToHsl(this._engine, bubbleColor);\n      }\n      if (!particle.bubble.finalColor) {\n        return;\n      }\n      if (bubbleOptions.mix) {\n        particle.bubble.color = undefined;\n        const pColor = particle.getFillColor();\n        particle.bubble.color = pColor ? rgbToHsl(colorMix(pColor, particle.bubble.finalColor, ratioOffset - ratio, ratio)) : particle.bubble.finalColor;\n      } else {\n        particle.bubble.color = particle.bubble.finalColor;\n      }\n    };\n    this._hoverBubbleOpacity = (particle, ratio, divBubble) => {\n      var _divBubble$opacity, _options$interactivit, _particle$opacity$val2, _particle$opacity2;\n      const container = this.container,\n        options = container.actualOptions,\n        modeOpacity = (_divBubble$opacity = divBubble === null || divBubble === void 0 ? void 0 : divBubble.opacity) !== null && _divBubble$opacity !== void 0 ? _divBubble$opacity : (_options$interactivit = options.interactivity.modes.bubble) === null || _options$interactivit === void 0 ? void 0 : _options$interactivit.opacity;\n      if (!modeOpacity) {\n        return;\n      }\n      const optOpacity = particle.options.opacity.value,\n        pOpacity = (_particle$opacity$val2 = (_particle$opacity2 = particle.opacity) === null || _particle$opacity2 === void 0 ? void 0 : _particle$opacity2.value) !== null && _particle$opacity$val2 !== void 0 ? _particle$opacity$val2 : defaultOpacity,\n        opacity = calculateBubbleValue(pOpacity, modeOpacity, getRangeMax(optOpacity), ratio);\n      if (opacity !== undefined) {\n        particle.bubble.opacity = opacity;\n      }\n    };\n    this._hoverBubbleSize = (particle, ratio, divBubble) => {\n      const container = this.container,\n        modeSize = divBubble !== null && divBubble !== void 0 && divBubble.size ? divBubble.size * container.retina.pixelRatio : container.retina.bubbleModeSize;\n      if (modeSize === undefined) {\n        return;\n      }\n      const optSize = getRangeMax(particle.options.size.value) * container.retina.pixelRatio,\n        pSize = particle.size.value,\n        size = calculateBubbleValue(pSize, modeSize, optSize, ratio);\n      if (size !== undefined) {\n        particle.bubble.radius = size;\n      }\n    };\n    this._process = (particle, distMouse, timeSpent, data) => {\n      var _data$particlesObj$va;\n      const container = this.container,\n        bubbleParam = data.bubbleObj.optValue,\n        options = container.actualOptions,\n        bubbleOptions = options.interactivity.modes.bubble;\n      if (!bubbleOptions || bubbleParam === undefined) {\n        return;\n      }\n      const bubbleDuration = bubbleOptions.duration,\n        bubbleDistance = container.retina.bubbleModeDistance,\n        particlesParam = data.particlesObj.optValue,\n        pObjBubble = data.bubbleObj.value,\n        pObj = (_data$particlesObj$va = data.particlesObj.value) !== null && _data$particlesObj$va !== void 0 ? _data$particlesObj$va : defaultBubbleValue,\n        type = data.type;\n      if (!bubbleDistance || bubbleDistance < minDistance || bubbleParam === particlesParam) {\n        return;\n      }\n      if (!container.bubble) {\n        container.bubble = {};\n      }\n      if (container.bubble.durationEnd) {\n        if (pObjBubble) {\n          if (type === ProcessBubbleType.size) {\n            delete particle.bubble.radius;\n          }\n          if (type === ProcessBubbleType.opacity) {\n            delete particle.bubble.opacity;\n          }\n        }\n      } else {\n        if (distMouse <= bubbleDistance) {\n          const obj = pObjBubble !== null && pObjBubble !== void 0 ? pObjBubble : pObj;\n          if (obj !== bubbleParam) {\n            const value = pObj - timeSpent * (pObj - bubbleParam) / bubbleDuration;\n            if (type === ProcessBubbleType.size) {\n              particle.bubble.radius = value;\n            }\n            if (type === ProcessBubbleType.opacity) {\n              particle.bubble.opacity = value;\n            }\n          }\n        } else {\n          if (type === ProcessBubbleType.size) {\n            delete particle.bubble.radius;\n          }\n          if (type === ProcessBubbleType.opacity) {\n            delete particle.bubble.opacity;\n          }\n        }\n      }\n    };\n    this._singleSelectorHover = (delta, selector, div) => {\n      const container = this.container,\n        selectors = document.querySelectorAll(selector),\n        bubble = container.actualOptions.interactivity.modes.bubble;\n      if (!bubble || !selectors.length) {\n        return;\n      }\n      selectors.forEach(item => {\n        const elem = item,\n          pxRatio = container.retina.pixelRatio,\n          pos = {\n            x: (elem.offsetLeft + elem.offsetWidth * half) * pxRatio,\n            y: (elem.offsetTop + elem.offsetHeight * half) * pxRatio\n          },\n          repulseRadius = elem.offsetWidth * half * pxRatio,\n          area = div.type === DivType.circle ? new Circle(pos.x, pos.y, repulseRadius) : new Rectangle(elem.offsetLeft * pxRatio, elem.offsetTop * pxRatio, elem.offsetWidth * pxRatio, elem.offsetHeight * pxRatio),\n          query = container.particles.quadTree.query(area, p => this.isEnabled(p));\n        for (const particle of query) {\n          if (!area.contains(particle.getPosition())) {\n            continue;\n          }\n          particle.bubble.inRange = true;\n          const divs = bubble.divs,\n            divBubble = divMode(divs, elem);\n          if (!particle.bubble.div || particle.bubble.div !== elem) {\n            this.clear(particle, delta, true);\n            particle.bubble.div = elem;\n          }\n          this._hoverBubbleSize(particle, defaultRatio, divBubble);\n          this._hoverBubbleOpacity(particle, defaultRatio, divBubble);\n          this._hoverBubbleColor(particle, defaultRatio, divBubble);\n        }\n      });\n    };\n    this._engine = engine;\n    if (!container.bubble) {\n      container.bubble = {};\n    }\n    this.handleClickMode = mode => {\n      if (mode !== bubbleMode) {\n        return;\n      }\n      if (!container.bubble) {\n        container.bubble = {};\n      }\n      container.bubble.clicking = true;\n    };\n  }\n  clear(particle, delta, force) {\n    if (particle.bubble.inRange && !force) {\n      return;\n    }\n    delete particle.bubble.div;\n    delete particle.bubble.opacity;\n    delete particle.bubble.radius;\n    delete particle.bubble.color;\n  }\n  init() {\n    const container = this.container,\n      bubble = container.actualOptions.interactivity.modes.bubble;\n    if (!bubble) {\n      return;\n    }\n    container.retina.bubbleModeDistance = bubble.distance * container.retina.pixelRatio;\n    if (bubble.size !== undefined) {\n      container.retina.bubbleModeSize = bubble.size * container.retina.pixelRatio;\n    }\n  }\n  interact(delta) {\n    const options = this.container.actualOptions,\n      events = options.interactivity.events,\n      onHover = events.onHover,\n      onClick = events.onClick,\n      hoverEnabled = onHover.enable,\n      hoverMode = onHover.mode,\n      clickEnabled = onClick.enable,\n      clickMode = onClick.mode,\n      divs = events.onDiv;\n    if (hoverEnabled && isInArray(bubbleMode, hoverMode)) {\n      this._hoverBubble();\n    } else if (clickEnabled && isInArray(bubbleMode, clickMode)) {\n      this._clickBubble();\n    } else {\n      divModeExecute(bubbleMode, divs, (selector, div) => this._singleSelectorHover(delta, selector, div));\n    }\n  }\n  isEnabled(particle) {\n    var _particle$interactivi;\n    const container = this.container,\n      options = container.actualOptions,\n      mouse = container.interactivity.mouse,\n      events = ((_particle$interactivi = particle === null || particle === void 0 ? void 0 : particle.interactivity) !== null && _particle$interactivi !== void 0 ? _particle$interactivi : options.interactivity).events,\n      {\n        onClick,\n        onDiv,\n        onHover\n      } = events,\n      divBubble = isDivModeEnabled(bubbleMode, onDiv);\n    if (!(divBubble || onHover.enable && !!mouse.position || onClick.enable && mouse.clickPosition)) {\n      return false;\n    }\n    return isInArray(bubbleMode, onHover.mode) || isInArray(bubbleMode, onClick.mode) || divBubble;\n  }\n  loadModeOptions(options) {\n    if (!options.bubble) {\n      options.bubble = new Bubble();\n    }\n    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      sources[_key - 1] = arguments[_key];\n    }\n    for (const source of sources) {\n      options.bubble.load(source === null || source === void 0 ? void 0 : source.bubble);\n    }\n  }\n  reset(particle) {\n    particle.bubble.inRange = false;\n  }\n}","map":{"version":3,"names":["Circle","DivType","ExternalInteractorBase","Rectangle","colorMix","divMode","divModeExecute","getDistance","getRangeMax","isDivModeEnabled","isInArray","itemFromSingleOrMultiple","millisecondsToSeconds","mouseLeaveEvent","mouseMoveEvent","rangeColorToHsl","rgbToHsl","Bubble","ProcessBubbleType","calculateBubbleValue","bubbleMode","minDistance","defaultClickTime","double","defaultOpacity","ratioOffset","defaultBubbleValue","minRatio","half","defaultRatio","Bubbler","constructor","container","engine","_clickBubble","options","actualOptions","mouseClickPos","interactivity","mouse","clickPosition","bubbleOptions","modes","bubble","distance","retina","bubbleModeDistance","query","particles","quadTree","queryCircle","p","isEnabled","particle","_container$interactiv","_particle$opacity$val","_particle$opacity","clicking","inRange","durationEnd","pos","getPosition","distMouse","timeSpent","Date","getTime","clickTime","duration","sizeData","bubbleObj","optValue","bubbleModeSize","value","radius","particlesObj","size","pixelRatio","type","_process","opacityData","opacity","_hoverBubbleColor","color","_hoverBubble","mousePos","position","pointDistance","ratio","status","_hoverBubbleSize","_hoverBubbleOpacity","reset","divBubble","finalColor","modeColor","bubbleColor","_engine","mix","undefined","pColor","getFillColor","_divBubble$opacity","_options$interactivit","_particle$opacity$val2","_particle$opacity2","modeOpacity","optOpacity","pOpacity","modeSize","optSize","pSize","data","_data$particlesObj$va","bubbleParam","bubbleDuration","bubbleDistance","particlesParam","pObjBubble","pObj","obj","_singleSelectorHover","delta","selector","div","selectors","document","querySelectorAll","length","forEach","item","elem","pxRatio","x","offsetLeft","offsetWidth","y","offsetTop","offsetHeight","repulseRadius","area","circle","contains","divs","clear","handleClickMode","mode","force","init","interact","events","onHover","onClick","hoverEnabled","enable","hoverMode","clickEnabled","clickMode","onDiv","_particle$interactivi","loadModeOptions","_len","arguments","sources","Array","_key","source","load"],"sources":["/Users/abolfaz/Downloads/my-project/node_modules/@tsparticles/interaction-external-bubble/browser/Bubbler.js"],"sourcesContent":["import { Circle, DivType, ExternalInteractorBase, Rectangle, colorMix, divMode, divModeExecute, getDistance, getRangeMax, isDivModeEnabled, isInArray, itemFromSingleOrMultiple, millisecondsToSeconds, mouseLeaveEvent, mouseMoveEvent, rangeColorToHsl, rgbToHsl, } from \"@tsparticles/engine\";\nimport { Bubble } from \"./Options/Classes/Bubble.js\";\nimport { ProcessBubbleType } from \"./Enums.js\";\nimport { calculateBubbleValue } from \"./Utils.js\";\nconst bubbleMode = \"bubble\", minDistance = 0, defaultClickTime = 0, double = 2, defaultOpacity = 1, ratioOffset = 1, defaultBubbleValue = 0, minRatio = 0, half = 0.5, defaultRatio = 1;\nexport class Bubbler extends ExternalInteractorBase {\n    constructor(container, engine) {\n        super(container);\n        this._clickBubble = () => {\n            const container = this.container, options = container.actualOptions, mouseClickPos = container.interactivity.mouse.clickPosition, bubbleOptions = options.interactivity.modes.bubble;\n            if (!bubbleOptions || !mouseClickPos) {\n                return;\n            }\n            if (!container.bubble) {\n                container.bubble = {};\n            }\n            const distance = container.retina.bubbleModeDistance;\n            if (!distance || distance < minDistance) {\n                return;\n            }\n            const query = container.particles.quadTree.queryCircle(mouseClickPos, distance, p => this.isEnabled(p)), { bubble } = container;\n            for (const particle of query) {\n                if (!bubble.clicking) {\n                    continue;\n                }\n                particle.bubble.inRange = !bubble.durationEnd;\n                const pos = particle.getPosition(), distMouse = getDistance(pos, mouseClickPos), timeSpent = (new Date().getTime() - (container.interactivity.mouse.clickTime ?? defaultClickTime)) /\n                    millisecondsToSeconds;\n                if (timeSpent > bubbleOptions.duration) {\n                    bubble.durationEnd = true;\n                }\n                if (timeSpent > bubbleOptions.duration * double) {\n                    bubble.clicking = false;\n                    bubble.durationEnd = false;\n                }\n                const sizeData = {\n                    bubbleObj: {\n                        optValue: container.retina.bubbleModeSize,\n                        value: particle.bubble.radius,\n                    },\n                    particlesObj: {\n                        optValue: getRangeMax(particle.options.size.value) * container.retina.pixelRatio,\n                        value: particle.size.value,\n                    },\n                    type: ProcessBubbleType.size,\n                };\n                this._process(particle, distMouse, timeSpent, sizeData);\n                const opacityData = {\n                    bubbleObj: {\n                        optValue: bubbleOptions.opacity,\n                        value: particle.bubble.opacity,\n                    },\n                    particlesObj: {\n                        optValue: getRangeMax(particle.options.opacity.value),\n                        value: particle.opacity?.value ?? defaultOpacity,\n                    },\n                    type: ProcessBubbleType.opacity,\n                };\n                this._process(particle, distMouse, timeSpent, opacityData);\n                if (!bubble.durationEnd && distMouse <= distance) {\n                    this._hoverBubbleColor(particle, distMouse);\n                }\n                else {\n                    delete particle.bubble.color;\n                }\n            }\n        };\n        this._hoverBubble = () => {\n            const container = this.container, mousePos = container.interactivity.mouse.position, distance = container.retina.bubbleModeDistance;\n            if (!distance || distance < minDistance || !mousePos) {\n                return;\n            }\n            const query = container.particles.quadTree.queryCircle(mousePos, distance, p => this.isEnabled(p));\n            for (const particle of query) {\n                particle.bubble.inRange = true;\n                const pos = particle.getPosition(), pointDistance = getDistance(pos, mousePos), ratio = ratioOffset - pointDistance / distance;\n                if (pointDistance <= distance) {\n                    if (ratio >= minRatio && container.interactivity.status === mouseMoveEvent) {\n                        this._hoverBubbleSize(particle, ratio);\n                        this._hoverBubbleOpacity(particle, ratio);\n                        this._hoverBubbleColor(particle, ratio);\n                    }\n                }\n                else {\n                    this.reset(particle);\n                }\n                if (container.interactivity.status === mouseLeaveEvent) {\n                    this.reset(particle);\n                }\n            }\n        };\n        this._hoverBubbleColor = (particle, ratio, divBubble) => {\n            const options = this.container.actualOptions, bubbleOptions = divBubble ?? options.interactivity.modes.bubble;\n            if (!bubbleOptions) {\n                return;\n            }\n            if (!particle.bubble.finalColor) {\n                const modeColor = bubbleOptions.color;\n                if (!modeColor) {\n                    return;\n                }\n                const bubbleColor = itemFromSingleOrMultiple(modeColor);\n                particle.bubble.finalColor = rangeColorToHsl(this._engine, bubbleColor);\n            }\n            if (!particle.bubble.finalColor) {\n                return;\n            }\n            if (bubbleOptions.mix) {\n                particle.bubble.color = undefined;\n                const pColor = particle.getFillColor();\n                particle.bubble.color = pColor\n                    ? rgbToHsl(colorMix(pColor, particle.bubble.finalColor, ratioOffset - ratio, ratio))\n                    : particle.bubble.finalColor;\n            }\n            else {\n                particle.bubble.color = particle.bubble.finalColor;\n            }\n        };\n        this._hoverBubbleOpacity = (particle, ratio, divBubble) => {\n            const container = this.container, options = container.actualOptions, modeOpacity = divBubble?.opacity ?? options.interactivity.modes.bubble?.opacity;\n            if (!modeOpacity) {\n                return;\n            }\n            const optOpacity = particle.options.opacity.value, pOpacity = particle.opacity?.value ?? defaultOpacity, opacity = calculateBubbleValue(pOpacity, modeOpacity, getRangeMax(optOpacity), ratio);\n            if (opacity !== undefined) {\n                particle.bubble.opacity = opacity;\n            }\n        };\n        this._hoverBubbleSize = (particle, ratio, divBubble) => {\n            const container = this.container, modeSize = divBubble?.size ? divBubble.size * container.retina.pixelRatio : container.retina.bubbleModeSize;\n            if (modeSize === undefined) {\n                return;\n            }\n            const optSize = getRangeMax(particle.options.size.value) * container.retina.pixelRatio, pSize = particle.size.value, size = calculateBubbleValue(pSize, modeSize, optSize, ratio);\n            if (size !== undefined) {\n                particle.bubble.radius = size;\n            }\n        };\n        this._process = (particle, distMouse, timeSpent, data) => {\n            const container = this.container, bubbleParam = data.bubbleObj.optValue, options = container.actualOptions, bubbleOptions = options.interactivity.modes.bubble;\n            if (!bubbleOptions || bubbleParam === undefined) {\n                return;\n            }\n            const bubbleDuration = bubbleOptions.duration, bubbleDistance = container.retina.bubbleModeDistance, particlesParam = data.particlesObj.optValue, pObjBubble = data.bubbleObj.value, pObj = data.particlesObj.value ?? defaultBubbleValue, type = data.type;\n            if (!bubbleDistance || bubbleDistance < minDistance || bubbleParam === particlesParam) {\n                return;\n            }\n            if (!container.bubble) {\n                container.bubble = {};\n            }\n            if (container.bubble.durationEnd) {\n                if (pObjBubble) {\n                    if (type === ProcessBubbleType.size) {\n                        delete particle.bubble.radius;\n                    }\n                    if (type === ProcessBubbleType.opacity) {\n                        delete particle.bubble.opacity;\n                    }\n                }\n            }\n            else {\n                if (distMouse <= bubbleDistance) {\n                    const obj = pObjBubble ?? pObj;\n                    if (obj !== bubbleParam) {\n                        const value = pObj - (timeSpent * (pObj - bubbleParam)) / bubbleDuration;\n                        if (type === ProcessBubbleType.size) {\n                            particle.bubble.radius = value;\n                        }\n                        if (type === ProcessBubbleType.opacity) {\n                            particle.bubble.opacity = value;\n                        }\n                    }\n                }\n                else {\n                    if (type === ProcessBubbleType.size) {\n                        delete particle.bubble.radius;\n                    }\n                    if (type === ProcessBubbleType.opacity) {\n                        delete particle.bubble.opacity;\n                    }\n                }\n            }\n        };\n        this._singleSelectorHover = (delta, selector, div) => {\n            const container = this.container, selectors = document.querySelectorAll(selector), bubble = container.actualOptions.interactivity.modes.bubble;\n            if (!bubble || !selectors.length) {\n                return;\n            }\n            selectors.forEach(item => {\n                const elem = item, pxRatio = container.retina.pixelRatio, pos = {\n                    x: (elem.offsetLeft + elem.offsetWidth * half) * pxRatio,\n                    y: (elem.offsetTop + elem.offsetHeight * half) * pxRatio,\n                }, repulseRadius = elem.offsetWidth * half * pxRatio, area = div.type === DivType.circle\n                    ? new Circle(pos.x, pos.y, repulseRadius)\n                    : new Rectangle(elem.offsetLeft * pxRatio, elem.offsetTop * pxRatio, elem.offsetWidth * pxRatio, elem.offsetHeight * pxRatio), query = container.particles.quadTree.query(area, p => this.isEnabled(p));\n                for (const particle of query) {\n                    if (!area.contains(particle.getPosition())) {\n                        continue;\n                    }\n                    particle.bubble.inRange = true;\n                    const divs = bubble.divs, divBubble = divMode(divs, elem);\n                    if (!particle.bubble.div || particle.bubble.div !== elem) {\n                        this.clear(particle, delta, true);\n                        particle.bubble.div = elem;\n                    }\n                    this._hoverBubbleSize(particle, defaultRatio, divBubble);\n                    this._hoverBubbleOpacity(particle, defaultRatio, divBubble);\n                    this._hoverBubbleColor(particle, defaultRatio, divBubble);\n                }\n            });\n        };\n        this._engine = engine;\n        if (!container.bubble) {\n            container.bubble = {};\n        }\n        this.handleClickMode = (mode) => {\n            if (mode !== bubbleMode) {\n                return;\n            }\n            if (!container.bubble) {\n                container.bubble = {};\n            }\n            container.bubble.clicking = true;\n        };\n    }\n    clear(particle, delta, force) {\n        if (particle.bubble.inRange && !force) {\n            return;\n        }\n        delete particle.bubble.div;\n        delete particle.bubble.opacity;\n        delete particle.bubble.radius;\n        delete particle.bubble.color;\n    }\n    init() {\n        const container = this.container, bubble = container.actualOptions.interactivity.modes.bubble;\n        if (!bubble) {\n            return;\n        }\n        container.retina.bubbleModeDistance = bubble.distance * container.retina.pixelRatio;\n        if (bubble.size !== undefined) {\n            container.retina.bubbleModeSize = bubble.size * container.retina.pixelRatio;\n        }\n    }\n    interact(delta) {\n        const options = this.container.actualOptions, events = options.interactivity.events, onHover = events.onHover, onClick = events.onClick, hoverEnabled = onHover.enable, hoverMode = onHover.mode, clickEnabled = onClick.enable, clickMode = onClick.mode, divs = events.onDiv;\n        if (hoverEnabled && isInArray(bubbleMode, hoverMode)) {\n            this._hoverBubble();\n        }\n        else if (clickEnabled && isInArray(bubbleMode, clickMode)) {\n            this._clickBubble();\n        }\n        else {\n            divModeExecute(bubbleMode, divs, (selector, div) => this._singleSelectorHover(delta, selector, div));\n        }\n    }\n    isEnabled(particle) {\n        const container = this.container, options = container.actualOptions, mouse = container.interactivity.mouse, events = (particle?.interactivity ?? options.interactivity).events, { onClick, onDiv, onHover } = events, divBubble = isDivModeEnabled(bubbleMode, onDiv);\n        if (!(divBubble || (onHover.enable && !!mouse.position) || (onClick.enable && mouse.clickPosition))) {\n            return false;\n        }\n        return isInArray(bubbleMode, onHover.mode) || isInArray(bubbleMode, onClick.mode) || divBubble;\n    }\n    loadModeOptions(options, ...sources) {\n        if (!options.bubble) {\n            options.bubble = new Bubble();\n        }\n        for (const source of sources) {\n            options.bubble.load(source?.bubble);\n        }\n    }\n    reset(particle) {\n        particle.bubble.inRange = false;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}